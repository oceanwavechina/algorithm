什么是递归

直观理解递归
    https://visualgo.net/zh/recursion

1. 递归 与 循环
    二者有相似之处，就是都要循环，都有结束循环的条件，在每一次循环中都做重复的事
    区别在于，
    循环从头到尾一遍就结束了，此时我们就得到了我们想要的结果
    递归则是 首先问题开始往前循环，一直循环到最前边不能再循环了为止，此时并没有计算，只是确定下要回去的路
            然后在最前边的位置开始往回走，边走边计算，一直回到原点，才得到我们想要的结果
            总的来说，就是先确定要计算的路线，然后按路线回退并计算结果
            可以说是从顶到底的过程，或是从问题开始入手
      
2. 如何分析递归问题      
    以 FibRecurs.cpp 为例, 第一行是斐波那契数列，第二行数列的索引
    
        0 1 1 2 3 5 8 ......
        1 2 3 4 5 6 7 ...... n-2 n-1 n
        
    首先要确定递归的关系是什么，这个问题中为 
        n = (n-1) + (n-2)
        
    问题是，我们要计算 fib(n), 根据关系，我们需要知道 fib(n-1) 和 f(n-2)， 
    于是进一步需要计算 fib(n-1) 需要知道 fib(n-2) 和 fib(n-3)
                    fib(n-2) 需要知道 fib(n-3) 和 fib(n-4)
    
                        依次类推
    
    如何写代码, 我们首先定义递归函数, 其中的n就是递归时需要计算的值

        long fib(n) {
        
        }
        
    然后实现递归条件, 根据递归条件有 fib(n) = fib(n-1) + fib(n=2), 则有

        long fib(n) {
            return fib(n-1) + fib(n-2)
        }
        
    到此，关系是有了，上边的代码会引导我们一直往前边走，不会停止，也就是条不归路，这样指定不行，
    我们在看看斐波那契数列是从哪里开始的，我们就要程序在哪里返回
    
                   ⎧    1                     n=1
            F(n) = ⎨    1                     n=2
                   ⎩    F(n−1)+F(n−2)         n≥3
            
    其起始条件就是 当 n=0 或是 n=1 时, 于是我们的代码修改为
​     
        long fib(n) {
            
            if( n==1 || n==2 ) {
                return 1;
            }
            
            return fib(n-1) + fib(n-2)
        }

    重点来了，我们改如何理解上边的代码，或是直观的理解
    难点是，这是一个循环，但是并不是一个常规的循环，或者说他不是 "一个" 循环，而是 "很多个" 循环
    我们每一次调用 fib() 函数，就是把一个待解决的问题暂时搁置起来(压栈)，画个图理解下, 从我们要解决的fib(n) 开始
                    
                    fib(n)
                   /      \
                  /  需计算 \
                 /          \
            fib(n-1)      fib(n-2)
      
     要点是，虽然形式上是如上图，但是计算机在执行代码的时候是有顺序的，首先说下压栈的流程，注意下，压栈压的是函数，也就是一个小问题
     程序每一次从入栈开始，直到没有可以压入的元素了，那此时栈里的这些待结局的小问题就是入栈开始的那个小问题的解
     比如我们计算fib(5), 从栈底到栈顶的，第一趟压栈为， 其中前边的元素等于后边的两个元素的和
     
        fib(5) -> fib(4) -> fib(3) -> fib(2) -> fib(1), 注意到1就是我们结束条件了，也就是斐波那契数列的起始了
        
      如果我们把上述小问题都求出来就能得到 fib(5) 了， 其计算过程也就是出栈的过程，
      
      问题来了，在出栈的时候，我们可能还要再次入栈，明白吗，比如我们计算依次出栈两个元素后有
      
        fib(5) -> fib(4) -> fib(3)=2
      
      接下来我们要计算 fib(4) 了，栈里边已经知道fib(3) 的值等于2， 还缺 fib(2) 的值，于是我们要在计算fib(2)的值，就有了
        
        fib(5) -> fib(4) -> fib(3)=2  -> fib(2)=1
        
      然后，出栈两次后， 我们就知道 fib(4) 的值了
      
        fib(5) -> fib(4)=3
      
      此时 fib(4) = fib(4) + fib(3),  但是此时没有 fib(3) 的值，于是又需要压栈计算
      
        fib(5) -> fib(4)=3 -> fib(3) -> fib(2) -> fib(1)
      
      如此不断在栈里边进进出出，
        进的时候，是因为我们 想要 知道 fib(x) 的计算路径，也就是需要哪些子问题
        出的时候，是因为我们 原路径返回，依次计算子问题，就知道了本趟第一次入栈的那个问题的答案